Интерфейс BlockingQueue является очередью (Queue), т.е. его элементы хранятся в порядке «первый пришел, первый вышел» (FIFO – first in, first out). Элементы, вставленные в коллекцию в определенном порядке, будут извлечены из нее в том же самом порядке. Также интерфейс гарантирует, что любая попытка извлечь элемент из пустой очереди заблокирует вызывающий поток до тех пор, пока в коллекции не появится элемент, который можно извлечь. Аналогично, любая попытка вставить элемент в заполненную очередь заблокирует вызывающий поток, пока в коллекции не освободится место для нового элемента.

BlockingQueue изящно решает проблему передачи элементов, собранных одним потоком, для обработки в другой поток без явных хлопот о проблемах синхронизации. Хорошим примером является способ Guarded Blocks из официального руководства Java. В нем создается ограниченный буфер с одним слотом, после чего потоки, используя ручную синхронизацию и методы wait()/notifyAll(), сигнализируют друг другу, когда в слоте имеется новый элемент для обработки и когда слот готов к помещению в него нового элемента (cм. подробности в реализации Guarded Blocks).

Хотя код из руководства Guarded Blocks работает, он выглядит длинным, путаным и не вполне интуитивно понятным. В начале развития платформы Java разработчикам приходилось иметь дело с подобным кодом, однако сейчас 2010 год – наверняка положение дел улучшилось?

В листинге 1 показана переписанная версия кода Guarded Blocks, где я использую ArrayBlockingQueue вместо написанного вручную типа Drop. 
