В Map имеется неочевидная ошибка параллелизма, которая вводит в заблуждение многих не знающих о ней Java-разработчиков. Легким решением данной проблемы является ConcurrentMap.

Когда доступ к коллекции Map осуществляется из нескольких потоков, перед сохранением пары ключ–значение часто с помощью методов containsKey() или get() определяется, имеется ли уже данный ключ в коллекции. Однако даже при использовании synchronized Map какой-либо поток может "подкрасться" и в середине процесса перехватить управление коллекцией Map. Проблема в том, что блокировка захватывается в начале вызова метода get(), затем освобождается, после чего снова захватывается в вызове метода put(). В результате может возникнуть гоночная ситуация между двумя потоками, итог которой может быть разным в зависимости от того, какой поток получит управление первым.

Если два потока вызывают метод в один и тот же момент времени, для каждого из них будет выполнена проверка, и каждый из них выполнит метод put, в результате чего значение, сохраненное первым потоком, будет потеряно. К счастью, интерфейс ConcurrentMap поддерживает несколько дополнительных методов, спроектированных для выполнения двух операций под одной блокировкой: например, метод putIfAbsent() сначала выполняет проверку, а затем помещает новое значение, только если данный ключ еще не хранится Map. 
